{
  "address": "0x244f2363444F1F190b6995fcc1aCA3f90415d907",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_AdjudicatorAddress",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "_Token",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "destination",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "AssetTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "destination",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "destinationHoldings",
          "type": "uint256"
        }
      ],
      "name": "Deposited",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "AdjudicatorAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "Token",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "assetOutcomeHashes",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guarantorChannelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "guaranteeBytes",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "allocationBytes",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "destination",
          "type": "bytes32"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guarantorChannelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "guaranteeBytes",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "allocationBytes",
          "type": "bytes"
        }
      ],
      "name": "claimAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "destination",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "expectedHeld",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "holdings",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "assetOutcomeHash",
          "type": "bytes32"
        }
      ],
      "name": "setAssetOutcomeHash",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "fromChannelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "allocationBytes",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "destination",
          "type": "bytes32"
        }
      ],
      "name": "transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "allocationBytes",
          "type": "bytes"
        }
      ],
      "name": "transferAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "channelId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "allocationBytes",
          "type": "bytes"
        }
      ],
      "name": "transferAllAdjudicatorOnly",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x11723a3205b04de3c941494adf7d1082d5f53939f7e17949f8b46dbcb579bede",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x87612aAD373586A38062c29F833A2AbC72038591",
    "contractAddress": null,
    "transactionIndex": 10,
    "gasUsed": "2137710",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf83406823739e1a6a8a01e307718259306d72a325f81a01b332a8d931494e789",
    "transactionHash": "0x11723a3205b04de3c941494adf7d1082d5f53939f7e17949f8b46dbcb579bede",
    "logs": [],
    "blockNumber": 7656941,
    "cumulativeGasUsed": "2533781",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x94Fca2E2F57B25b2D9eA5d4FCEd6c5d8d9ad3172",
    "0xEE782846F3b1ee71a336F41714D2b2E0B3550B1f"
  ],
  "solcInputHash": "ab20556954f60f95e893e4797a67279d",
  "metadata": "{\"compiler\":{\"version\":\"0.7.4+commit.3f05b770\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_AdjudicatorAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_Token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AssetTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationHoldings\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AdjudicatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"assetOutcomeHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guarantorChannelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"guaranteeBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"allocationBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guarantorChannelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"guaranteeBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"allocationBytes\",\"type\":\"bytes\"}],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expectedHeld\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"holdings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"assetOutcomeHash\",\"type\":\"bytes32\"}],\"name\":\"setAssetOutcomeHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"fromChannelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"allocationBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"allocationBytes\",\"type\":\"bytes\"}],\"name\":\"transferAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"allocationBytes\",\"type\":\"bytes\"}],\"name\":\"transferAllAdjudicatorOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Ther ERC20AssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ERC20 tokens to be escrowed against a state channelId and to be transferred to external destinations.\",\"kind\":\"dev\",\"methods\":{\"claim(bytes32,bytes,bytes,bytes32)\":{\"details\":\"Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\",\"params\":{\"allocationBytes\":\"The abi.encode of AssetOutcome.Allocation for the __target__\",\"destination\":\"External destination or channel to transfer funds *to*.\",\"guaranteeBytes\":\"The abi.encode of Outcome.Guarantee\",\"guarantorChannelId\":\"Unique identifier for a guarantor state channel.\"}},\"claimAll(bytes32,bytes,bytes)\":{\"details\":\"Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\",\"params\":{\"allocationBytes\":\"The abi.encode of AssetOutcome.Allocation for the __target__\",\"guaranteeBytes\":\"The abi.encode of Outcome.Guarantee\",\"guarantorChannelId\":\"Unique identifier for a guarantor state channel.\"}},\"constructor\":{\"details\":\"Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\",\"params\":{\"_AdjudicatorAddress\":\"Address of an Adjudicator  contract, supplied at deploy-time.\",\"_Token\":\"An ERC20 Token  contract, supplied at deploy-time.\"}},\"deposit(bytes32,uint256,uint256)\":{\"details\":\"Deposit ERC20 tokens against a given destination.\",\"params\":{\"amount\":\"The intended number of tokens to be deposited.\",\"destination\":\"ChannelId to be credited.\",\"expectedHeld\":\"The amount of tokens that the depositor believes are _already_ escrowed against the channelId.\"}},\"setAssetOutcomeHash(bytes32,bytes32)\":{\"details\":\"Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\",\"params\":{\"assetOutcomeHash\":\"The keccak256 of the abi.encode of the Outcome.\",\"channelId\":\"Unique identifier for a state channel.\"}},\"transfer(bytes32,bytes,bytes32)\":{\"details\":\"Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\",\"params\":{\"allocationBytes\":\"The abi.encode of AssetOutcome.Allocation\",\"destination\":\"External destination or channel to transfer funds *to*.\",\"fromChannelId\":\"Unique identifier for state channel to transfer funds *from*.\"}},\"transferAll(bytes32,bytes)\":{\"details\":\"Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.\",\"params\":{\"allocationBytes\":\"The abi.encode of AssetOutcome.Allocation\",\"channelId\":\"Unique identifier for a state channel.\"}},\"transferAllAdjudicatorOnly(bytes32,bytes)\":{\"details\":\"Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\",\"params\":{\"allocationBytes\":\"The abi.encode of AssetOutcome.Allocation\",\"channelId\":\"Unique identifier for a state channel.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claim(bytes32,bytes,bytes,bytes32)\":{\"notice\":\"Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\"},\"claimAll(bytes32,bytes,bytes)\":{\"notice\":\"Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\"},\"constructor\":{\"notice\":\"Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\"},\"deposit(bytes32,uint256,uint256)\":{\"notice\":\"Deposit ERC20 tokens against a given destination.\"},\"setAssetOutcomeHash(bytes32,bytes32)\":{\"notice\":\"Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\"},\"transfer(bytes32,bytes,bytes32)\":{\"notice\":\"Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\"},\"transferAll(bytes32,bytes)\":{\"notice\":\"Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract.\"},\"transferAllAdjudicatorOnly(bytes32,bytes)\":{\"notice\":\"Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ERC20AssetHolder.sol\":\"ERC20AssetHolder\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xba96bc371ba999f452985a98717cca1e4c4abb598dc038a9a9c3db08129b1ba4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbd74f587ab9b9711801baf667db1426e4a03fd2d7f15af33e0e0d0394e7cef76\",\"license\":\"MIT\"},\"contracts/AssetHolder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport './Outcome.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport './interfaces/IAssetHolder.sol';\\n\\n/**\\n * @dev An implementation of the IAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channel and/or external destinations, as well as for guarantees to be claimed. Note there is no deposit function and the _transferAsset function is unimplemented; inheriting contracts should implement these functions in a manner appropriate to the asset type (e.g. ETH or ERC20 tokens).\\n */\\ncontract AssetHolder is IAssetHolder {\\n    using SafeMath for uint256;\\n\\n    address public AdjudicatorAddress;\\n\\n    mapping(bytes32 => uint256) public holdings;\\n\\n    mapping(bytes32 => bytes32) public assetOutcomeHashes;\\n\\n    // **************\\n    // External methods\\n    // **************\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     * @param destination External destination or channel to transfer funds *to*.\\n     */\\n    function transfer(\\n        bytes32 fromChannelId,\\n        bytes calldata allocationBytes,\\n        bytes32 destination\\n    ) external {\\n        // checks\\n        _requireCorrectAllocationHash(fromChannelId, allocationBytes);\\n        // effects and interactions\\n        _transfer(fromChannelId, allocationBytes, destination);\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function transferAll(bytes32 channelId, bytes calldata allocationBytes) external override {\\n        // checks\\n        _requireCorrectAllocationHash(channelId, allocationBytes);\\n        // effects and interactions\\n        _transferAll(channelId, allocationBytes);\\n    }\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\\n     * @dev Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     * @param destination External destination or channel to transfer funds *to*.\\n     */\\n    function claim(\\n        bytes32 guarantorChannelId,\\n        bytes calldata guaranteeBytes,\\n        bytes calldata allocationBytes,\\n        bytes32 destination\\n    ) external {\\n        // checks\\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\\n        // effects and interactions\\n        _claim(guarantorChannelId, guarantee, allocationBytes, destination);\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     */\\n    function claimAll(\\n        bytes32 guarantorChannelId,\\n        bytes calldata guaranteeBytes,\\n        bytes calldata allocationBytes\\n    ) external override {\\n        // checks\\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\\n        // effects and interactions\\n        _claimAll(guarantorChannelId, guarantee, allocationBytes);\\n    }\\n\\n    // **************\\n    // Permissioned methods\\n    // **************\\n\\n    modifier AdjudicatorOnly {\\n        require(msg.sender == AdjudicatorAddress, 'Only the NitroAdjudicator is authorized');\\n        _;\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function transferAllAdjudicatorOnly(bytes32 channelId, bytes calldata allocationBytes)\\n        external\\n        virtual\\n        AdjudicatorOnly\\n    {\\n        // no checks\\n        //\\n        // effects and interactions\\n        _transferAll(channelId, allocationBytes);\\n    }\\n\\n    /**\\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\\n     */\\n    function setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash)\\n        external\\n        AdjudicatorOnly\\n        returns (bool success)\\n    {\\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\\n        return true;\\n    }\\n\\n    // **************\\n    // Internal methods\\n    // **************\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     * @param destination External destination or channel to transfer funds *to*.\\n     */\\n    function _transfer(\\n        bytes32 fromChannelId,\\n        bytes memory allocationBytes,\\n        bytes32 destination\\n    ) internal {\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        );\\n        uint256 balance = holdings[fromChannelId];\\n        uint256 affordsForDestination;\\n        uint256 residualAllocationAmount;\\n        uint256 i;\\n        bool deleteHash = false;\\n\\n        // loop over allocations and decrease balance until we hit the specified destination\\n        for (i = 0; i < allocation.length; i++) {\\n            if (balance == 0) {\\n                revert('_transfer | fromChannel affords 0 for destination');\\n            }\\n            uint256 _amount = allocation[i].amount;\\n            if (allocation[i].destination == destination) {\\n                if (balance < _amount) {\\n                    affordsForDestination = balance;\\n                    residualAllocationAmount = _amount - balance;\\n                    balance = 0;\\n                } else {\\n                    affordsForDestination = _amount;\\n                    residualAllocationAmount = 0;\\n                    balance = balance.sub(_amount);\\n                }\\n                break; // means that i holds the index of the destination that may need to be altered or removed\\n            }\\n            if (balance < _amount) {\\n                balance = 0;\\n            } else {\\n                balance = balance.sub(_amount);\\n            }\\n        }\\n\\n        require(affordsForDestination > 0, '_transfer fromChannel allocates 0 to destination');\\n\\n        // effects\\n        holdings[fromChannelId] -= affordsForDestination;\\n\\n        // construct new outcome\\n\\n        bytes memory encodedAllocation;\\n\\n        if (residualAllocationAmount > 0) {\\n            // new allocation identical save for a single entry\\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\\n                allocation.length\\n            );\\n            for (uint256 k = 0; k < allocation.length; k++) {\\n                newAllocation[k] = allocation[k];\\n                if (allocation[k].destination == destination) {\\n                    newAllocation[k].amount = residualAllocationAmount;\\n                }\\n            }\\n            encodedAllocation = abi.encode(newAllocation);\\n        }\\n\\n        if (residualAllocationAmount == 0) {\\n            Outcome.AllocationItem[] memory splicedAllocation = new Outcome.AllocationItem[](\\n                allocation.length - 1\\n            );\\n            // full payout so we want to splice a shorter outcome\\n            for (uint256 k = 0; k < i; k++) {\\n                splicedAllocation[k] = allocation[k];\\n            }\\n            for (uint256 k = i + 1; k < allocation.length; k++) {\\n                splicedAllocation[k - 1] = allocation[k];\\n            }\\n            if (splicedAllocation.length == 0) {\\n                deleteHash = true;\\n            }\\n            encodedAllocation = abi.encode(splicedAllocation);\\n        }\\n\\n        // replace or delete hash\\n        if (deleteHash) {\\n            delete assetOutcomeHashes[fromChannelId];\\n        } else {\\n            assetOutcomeHashes[fromChannelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        encodedAllocation\\n                    )\\n                )\\n            );\\n        }\\n\\n        // storage updated BEFORE external contracts called (prevent reentrancy attacks)\\n        if (_isExternalDestination(destination)) {\\n            _transferAsset(_bytes32ToAddress(destination), affordsForDestination);\\n        } else {\\n            holdings[destination] += affordsForDestination;\\n        }\\n        // Event emitted\\n        emit AssetTransferred(fromChannelId, destination, affordsForDestination);\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Does not check allocationBytes against on chain storage.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Does not check allocationBytes against on chain storage.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function _transferAll(bytes32 channelId, bytes memory allocationBytes) internal {\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        );\\n        uint256 balance = holdings[channelId];\\n        uint256 numPayouts = 0;\\n        uint256 numNewAllocationItems = allocation.length;\\n        uint256 _amount;\\n        bool overlap;\\n        uint256 finalPayoutAmount;\\n        uint256 firstNewAllocationItemAmount;\\n\\n        for (uint256 i = 0; i < allocation.length; i++) {\\n            if (balance == 0) {\\n                // if funds are completely depleted, keep the allocationItem and do not pay out\\n                break;\\n            } else {\\n                _amount = allocation[i].amount;\\n                if (balance < _amount) {\\n                    // if funds still exist but are insufficient for this allocationItem, payout what's available and keep the allocationItem (but reduce the amount allocated)\\n                    // this block is never executed more than once\\n                    numPayouts++;\\n                    overlap = true;\\n                    finalPayoutAmount = balance;\\n                    firstNewAllocationItemAmount = _amount.sub(balance);\\n                    balance = 0;\\n                } else {\\n                    // if ample funds still exist, pay them out and discard the allocationItem\\n                    numPayouts++;\\n                    numNewAllocationItems = numNewAllocationItems.sub(1);\\n                    balance = balance.sub(_amount);\\n                }\\n            }\\n        }\\n\\n        // effects\\n        holdings[channelId] = balance;\\n\\n        if (numNewAllocationItems > 0) {\\n            // construct newAllocation\\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\\n                numNewAllocationItems\\n            );\\n            for (uint256 k = 0; k < numNewAllocationItems; k++) {\\n                newAllocation[k] = allocation[allocation.length.sub(numNewAllocationItems).add(k)];\\n                if (overlap && k == 0) {\\n                    newAllocation[k].amount = firstNewAllocationItemAmount;\\n                }\\n            }\\n\\n            // store hash\\n            assetOutcomeHashes[channelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        abi.encode(newAllocation)\\n                    )\\n                )\\n            );\\n        } else {\\n            delete assetOutcomeHashes[channelId];\\n        }\\n\\n        // holdings updated BEFORE asset transferred (prevent reentrancy attacks)\\n        uint256 payoutAmount;\\n        for (uint256 m = 0; m < numPayouts; m++) {\\n            if (overlap && m == numPayouts.sub(1)) {\\n                payoutAmount = finalPayoutAmount;\\n            } else {\\n                payoutAmount = allocation[m].amount;\\n            }\\n            if (_isExternalDestination(allocation[m].destination)) {\\n                _transferAsset(_bytes32ToAddress(allocation[m].destination), payoutAmount);\\n            } else {\\n                holdings[allocation[m].destination] += payoutAmount;\\n            }\\n            // Event emitted\\n            emit AssetTransferred(channelId, allocation[m].destination, payoutAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel.  Does not check allocationBytes or guarantee against on chain storage.\\n     * @dev Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel.  Does not check allocationBytes or guarantee against on chain storage.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guarantee The guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     * @param destination External destination or channel to transfer funds *to*.\\n     */\\n    function _claim(\\n        bytes32 guarantorChannelId,\\n        Outcome.Guarantee memory guarantee,\\n        bytes memory allocationBytes,\\n        bytes32 destination\\n    ) internal {\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        );\\n        uint256 balance = holdings[guarantorChannelId];\\n        uint256 affordsForDestination;\\n        uint256 residualAllocationAmount;\\n        uint256 i; // indexes target allocations\\n\\n        for (uint256 j = 0; j < guarantee.destinations.length; j++) {\\n            if (balance == 0) {\\n                revert('_claim | guarantorChannel affords 0 for destination');\\n            }\\n            // for each destination in the guarantee,\\n            // find the first corresponding allocationItem in the target allocation\\n            bytes32 guaranteeDestination = guarantee.destinations[j];\\n            for (i = 0; i < allocation.length; i++) {\\n                if (allocation[i].destination == guaranteeDestination) {\\n                    // decrease balance\\n                    uint256 _amount = allocation[i].amount;\\n                    if (balance < _amount) {\\n                        if (guaranteeDestination == destination) {\\n                            affordsForDestination = balance;\\n                            residualAllocationAmount = _amount - balance;\\n                            break;\\n                            // i will point to index that should be modified or removed in the target outcome\\n                        }\\n                        balance = 0; // this isn't used after we break\\n                    } else {\\n                        if (guaranteeDestination == destination) {\\n                            affordsForDestination = _amount;\\n                            residualAllocationAmount = 0;\\n                            break;\\n                            // i will point to index that should be modified or removed in the target outcome\\n                        }\\n                        balance = balance.sub(_amount); // this isn't used after we break\\n                    }\\n                    break;\\n                }\\n            }\\n            if (affordsForDestination > 0) {\\n                // stop lopping as soon as we found the destination in both outcomes such that we can pay something out\\n                break;\\n            }\\n        }\\n\\n        require(affordsForDestination > 0, '_claim | guarantor affords 0 for destination');\\n\\n        // effects\\n        holdings[guarantorChannelId] -= affordsForDestination;\\n\\n        // construct new outcome for target\\n        if (residualAllocationAmount > 0) {\\n            // new allocation identical save for a single entry\\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\\n                allocation.length\\n            );\\n            for (uint256 k = 0; k < allocation.length; k++) {\\n                newAllocation[k] = allocation[k];\\n                if (k == i) {\\n                    newAllocation[k].amount = residualAllocationAmount;\\n                    break;\\n                }\\n            }\\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        abi.encode(newAllocation)\\n                    )\\n                )\\n            );\\n        }\\n\\n        if (residualAllocationAmount == 0) {\\n            // We want to splice a shorter outcome\\n            if (allocation.length == 1) {\\n                // special case there are no allocations left in the target's outcome\\n                delete assetOutcomeHashes[guarantee.targetChannelId];\\n                delete assetOutcomeHashes[guarantorChannelId];\\n            } else {\\n                Outcome.AllocationItem[] memory splicedAllocation = new Outcome.AllocationItem[](\\n                    allocation.length - 1\\n                );\\n                for (uint256 k = 0; k < i; k++) {\\n                    splicedAllocation[k] = allocation[k];\\n                }\\n                for (uint256 k = i + 1; k < allocation.length; k++) {\\n                    splicedAllocation[k - 1] = allocation[k];\\n                }\\n                assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\\n                    abi.encode(\\n                        Outcome.AssetOutcome(\\n                            uint8(Outcome.AssetOutcomeType.Allocation),\\n                            abi.encode(splicedAllocation)\\n                        )\\n                    )\\n                );\\n            }\\n        }\\n\\n        // storage updated BEFORE external contracts called (prevent reentrancy attacks)\\n        if (_isExternalDestination(destination)) {\\n            _transferAsset(_bytes32ToAddress(destination), affordsForDestination);\\n        } else {\\n            holdings[destination] += affordsForDestination;\\n        }\\n        // Event emitted\\n        emit AssetTransferred(guarantorChannelId, destination, affordsForDestination);\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes or guarantee against on chain storage.\\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes or guarantee against on chain storage.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guarantee The guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     */\\n    function _claimAll(\\n        bytes32 guarantorChannelId,\\n        Outcome.Guarantee memory guarantee,\\n        bytes memory allocationBytes\\n    ) internal {\\n        uint256 balance = holdings[guarantorChannelId];\\n\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        ); // this remains constant length\\n\\n        uint256[] memory payouts = new uint256[](allocation.length);\\n        uint256 newAllocationLength = allocation.length;\\n\\n        // first increase payouts according to guarantee\\n        for (uint256 i = 0; i < guarantee.destinations.length; i++) {\\n            if (balance == 0) {\\n                break;\\n            }\\n            // for each destination in the guarantee\\n            bytes32 _destination = guarantee.destinations[i];\\n            for (uint256 j = 0; j < allocation.length; j++) {\\n                if (balance == 0) {\\n                    break;\\n                }\\n                if (_destination == allocation[j].destination) {\\n                    // find amount allocated to that destination (if it exists in channel alllocation)\\n                    uint256 _amount = allocation[j].amount;\\n                    if (_amount > 0) {\\n                        if (balance >= _amount) {\\n                            balance = balance.sub(_amount);\\n                            allocation[j].amount = 0; // subtract _amount;\\n                            newAllocationLength = newAllocationLength.sub(1);\\n                            payouts[j] += _amount;\\n                            break;\\n                        } else {\\n                            allocation[j].amount = _amount.sub(balance);\\n                            payouts[j] += balance;\\n                            balance = 0;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // next, increase payouts according to original allocation order\\n        // this block only has an effect if balance > 0\\n        for (uint256 j = 0; j < allocation.length; j++) {\\n            // for each entry in the target channel's outcome\\n            if (balance == 0) {\\n                break;\\n            }\\n            uint256 _amount = allocation[j].amount;\\n            if (_amount > 0) {\\n                if (balance >= _amount) {\\n                    balance = balance.sub(_amount);\\n                    allocation[j].amount = 0; // subtract _amount;\\n                    newAllocationLength = newAllocationLength.sub(1);\\n                    payouts[j] += _amount;\\n                } else {\\n                    allocation[j].amount = _amount.sub(balance);\\n                    payouts[j] += balance;\\n                    balance = 0;\\n                }\\n            }\\n        }\\n\\n        // EFFECTS\\n        holdings[guarantorChannelId] = balance;\\n\\n        // at this point have payouts array of uint256s, each corresponding to original destinations\\n        // and allocations has some zero amounts which we want to prune\\n        Outcome.AllocationItem[] memory newAllocation;\\n        if (newAllocationLength > 0) {\\n            newAllocation = new Outcome.AllocationItem[](newAllocationLength);\\n        }\\n\\n        uint256 k = 0;\\n        for (uint256 j = 0; j < allocation.length; j++) {\\n            // for each destination in the target channel's allocation\\n            if (allocation[j].amount > 0) {\\n                newAllocation[k] = allocation[j];\\n                k++;\\n            }\\n        }\\n        assert(k == newAllocationLength);\\n\\n        if (newAllocationLength > 0) {\\n            // store hash\\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        abi.encode(newAllocation)\\n                    )\\n                )\\n            );\\n        } else {\\n            delete assetOutcomeHashes[guarantorChannelId];\\n            delete assetOutcomeHashes[guarantee.targetChannelId];\\n        }\\n\\n        // INTERACTIONS\\n        for (uint256 j = 0; j < allocation.length; j++) {\\n            // for each destination in the target channel's allocation\\n            if (payouts[j] > 0) {\\n                if (_isExternalDestination(allocation[j].destination)) {\\n                    _transferAsset(_bytes32ToAddress(allocation[j].destination), payouts[j]);\\n                } else {\\n                    holdings[allocation[j].destination] += payouts[j];\\n                }\\n                emit AssetTransferred(guarantorChannelId, allocation[j].destination, payouts[j]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\\n     * @param channelId Unique identifier for a state channel.\\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\\n     */\\n    function _setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash) internal {\\n        require(assetOutcomeHashes[channelId] == bytes32(0), 'Outcome hash already exists');\\n        assetOutcomeHashes[channelId] = assetOutcomeHash;\\n    }\\n\\n    /**\\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\\n     * @param destination ethereum address to be credited.\\n     * @param amount Quantity of assets to be transferred.\\n     */\\n    function _transferAsset(address payable destination, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\\n     * @param destination Destination to be checked.\\n     * @return True if the destination is external, false otherwise.\\n     */\\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\\n        return uint96(bytes12(destination)) == 0;\\n    }\\n\\n    /**\\n     * @notice Converts an ethereum address to a nitro external destination.\\n     * @dev Converts an ethereum address to a nitro external destination.\\n     * @param participant The address to be converted.\\n     * @return The input address left-padded with zeros.\\n     */\\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\\n        return bytes32(uint256(participant));\\n    }\\n\\n    /**\\n     * @notice Converts a nitro destination to an ethereum address.\\n     * @dev Converts a nitro destination to an ethereum address.\\n     * @param destination The destination to be converted.\\n     * @return The rightmost 160 bits of the input string.\\n     */\\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\\n        return address(uint160(uint256(destination)));\\n    }\\n\\n    // **************\\n    // Requirers\\n    // **************\\n\\n    function _requireCorrectAllocationHash(bytes32 channelId, bytes memory allocationBytes)\\n        internal\\n        view\\n    {\\n        require(\\n            assetOutcomeHashes[channelId] ==\\n                keccak256(\\n                    abi.encode(\\n                        Outcome.AssetOutcome(\\n                            uint8(Outcome.AssetOutcomeType.Allocation),\\n                            allocationBytes\\n                        )\\n                    )\\n                ),\\n            'AssetHolder | submitted allocationBytes data does not match stored assetOutcomeHash'\\n        );\\n    }\\n\\n    function _requireCorrectGuaranteeHash(bytes32 guarantorChannelId, bytes memory guaranteeBytes)\\n        internal\\n        view\\n    {\\n        require(\\n            assetOutcomeHashes[guarantorChannelId] ==\\n                keccak256(\\n                    abi.encode(\\n                        Outcome.AssetOutcome(\\n                            uint8(Outcome.AssetOutcomeType.Guarantee),\\n                            guaranteeBytes\\n                        )\\n                    )\\n                ),\\n            'AssetHolder | submitted guaranteeBytes data does not match stored assetOutcomeHash'\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x65cc5798c93e945cf458942b37400b25c3f6b5440dac66877d18d5369eba452e\",\"license\":\"MIT\"},\"contracts/ERC20AssetHolder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport './AssetHolder.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @dev Ther ERC20AssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ERC20 tokens to be escrowed against a state channelId and to be transferred to external destinations.\\n */\\ncontract ERC20AssetHolder is AssetHolder {\\n    using SafeMath for uint256;\\n\\n    IERC20 public Token;\\n\\n    /**\\n     * @notice Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\\n     * @dev Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\\n     * @param _Token An ERC20 Token  contract, supplied at deploy-time.\\n     */\\n    constructor(address _AdjudicatorAddress, IERC20 _Token) {\\n        AdjudicatorAddress = _AdjudicatorAddress;\\n        Token = _Token;\\n    }\\n\\n    /**\\n     * @notice Deposit ERC20 tokens against a given destination.\\n     * @dev Deposit ERC20 tokens against a given destination.\\n     * @param destination ChannelId to be credited.\\n     * @param expectedHeld The amount of tokens that the depositor believes are _already_ escrowed against the channelId.\\n     * @param amount The intended number of tokens to be deposited.\\n     */\\n    function deposit(\\n        bytes32 destination,\\n        uint256 expectedHeld,\\n        uint256 amount\\n    ) external {\\n        require(!_isExternalDestination(destination), 'Cannot deposit to external destination');\\n        uint256 amountDeposited;\\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\\n        // 1. Participant A deposits\\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\\n        // 3. Participant B submits their deposit\\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\\n        require(\\n            holdings[destination] >= expectedHeld,\\n            'Deposit | holdings[destination] is less than expected'\\n        );\\n        require(\\n            holdings[destination] < expectedHeld.add(amount),\\n            'Deposit | holdings[destination] already meets or exceeds expectedHeld + amount'\\n        );\\n\\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\\n\\n        amountDeposited = expectedHeld.add(amount).sub(holdings[destination]); // strictly positive\\n        // require successful deposit before updating holdings (protect against reentrancy)\\n        require(\\n            Token.transferFrom(msg.sender, address(this), amountDeposited),\\n            'Could not deposit ERC20s'\\n        );\\n        holdings[destination] = holdings[destination].add(amountDeposited);\\n        emit Deposited(destination, amountDeposited, holdings[destination]);\\n    }\\n\\n    /**\\n     * @notice Transfers the given amount of ERC20 tokens to a supplied ethereum address.\\n     * @dev Transfers the given amount of ERC20 tokens to a supplied ethereum address.\\n     * @param destination Ethereum address to be credited.\\n     * @param amount Quantity of tokens to be transferred.\\n     */\\n    function _transferAsset(address payable destination, uint256 amount) internal virtual override {\\n        require(Token.transfer(destination, amount), 'Could not transfer ERC20 tokens');\\n    }\\n}\\n\",\"keccak256\":\"0x3817770fb81d0c9b189756b7c35e2f7803f0eb3aa0d3f46e0b006f5a554d1a94\",\"license\":\"MIT\"},\"contracts/Outcome.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Outcome {\\n    //An outcome is an array of OutcomeItems\\n    // Outcome = OutcomeItem[]\\n    // OutcomeItem = (AssetHolderAddress, AssetOutcome)\\n    // AssetOutcome = (AssetOutcomeType, Allocation | Guarantee)\\n    // Allocation = AllocationItem[]\\n    // AllocationItem = (Destination, Amount)\\n    // Guarantee = (ChannelAddress, Destination[])\\n    // Destination = ChannelAddress | ExternalDestination\\n\\n    struct OutcomeItem {\\n        address assetHolderAddress;\\n        bytes assetOutcomeBytes; // abi.encode(AssetOutcome)\\n    }\\n\\n    enum AssetOutcomeType {Allocation, Guarantee}\\n\\n    struct AssetOutcome {\\n        uint8 assetOutcomeType; // AssetOutcomeType.Allocation or AssetOutcomeType.Guarantee\\n        bytes allocationOrGuaranteeBytes; // abi.encode(AllocationItem[]) or abi.encode(Guarantee), depending on OutcomeType\\n    }\\n\\n    // reserve Allocation to refer to AllocationItem[]\\n    struct AllocationItem {\\n        bytes32 destination;\\n        uint256 amount;\\n    }\\n\\n    struct Guarantee {\\n        bytes32 targetChannelId;\\n        bytes32[] destinations;\\n    }\\n}\\n\",\"keccak256\":\"0x2d3d3ecf6a28246633ad3e19bdebd4f93fcea1202b7ff38c729a29f74da408bf\",\"license\":\"MIT\"},\"contracts/interfaces/IAssetHolder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev The IAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\\n */\\ninterface IAssetHolder {\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function transferAll(bytes32 channelId, bytes calldata allocationBytes) external;\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     */\\n    function claimAll(\\n        bytes32 guarantorChannelId,\\n        bytes calldata guaranteeBytes,\\n        bytes calldata allocationBytes\\n    ) external;\\n\\n    /**\\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\\n     * @param destination The channel being deposited into.\\n     * @param amountDeposited The amount being deposited.\\n     * @param destinationHoldings The new holdings for `destination`.\\n     */\\n    event Deposited(\\n        bytes32 indexed destination,\\n        uint256 amountDeposited,\\n        uint256 destinationHoldings\\n    );\\n\\n    /**\\n     * @dev Indicates that `amount` assets have been transferred (internally or externally) to the destination denoted by `destination`.\\n     * @param channelId The channelId of the funds being withdrawn.\\n     * @param destination An internal destination (channelId) of external destination (padded ethereum address)\\n     * @param amount Number of assets transferred (wei or tokens).\\n     */\\n    event AssetTransferred(bytes32 indexed channelId, bytes32 indexed destination, uint256 amount);\\n}\\n\",\"keccak256\":\"0x63a4ed7714adb2f4d42c1d8eb57f7f71d3fff16d4fb649953a02a469512f0c08\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200259c3803806200259c833981016040819052620000349162000066565b600080546001600160a01b039384166001600160a01b03199182161790915560038054929093169116179055620000bd565b6000806040838503121562000079578182fd5b82516200008681620000a4565b60208401519092506200009981620000a4565b809150509250929050565b6001600160a01b0381168114620000ba57600080fd5b50565b6124cf80620000cd6000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c8063a3c863a311610071578063a3c863a31461010f578063aa5f665514610138578063ae9ee18c1461014d578063c24126761461016d578063f1c9caf214610175578063ff86097614610188576100a9565b8063022cbbe8146100ae578063278f2ab8146100c35780632e36b7f8146100d657806394ddd766146100e9578063a3c041a1146100fc575b600080fd5b6100c16100bc366004611c50565b61019b565b005b6100c16100d1366004611ddd565b610213565b6100c16100e4366004611c50565b6103cd565b6100c16100f7366004611d5f565b61040d565b6100c161010a366004611c99565b6104f3565b61012261011d366004611c2f565b61057b565b60405161012f9190611f83565b60405180910390f35b6101406105b9565b60405161012f9190611ee3565b61016061015b366004611c17565b6105c8565b60405161012f9190611f8e565b6101406105da565b6100c1610183366004611ce9565b6105e9565b610160610196366004611c17565b6106cc565b6000546001600160a01b031633146101ce5760405162461bcd60e51b81526004016101c590612260565b60405180910390fd5b61020e8383838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506106de92505050565b505050565b61021c83610a24565b156102395760405162461bcd60e51b81526004016101c5906120b0565b6000838152600160205260408120548311156102675760405162461bcd60e51b81526004016101c590611fe3565b6102718383610a2b565b6000858152600160205260409020541061029d5760405162461bcd60e51b81526004016101c5906121b5565b6000848152600160205260409020546102c0906102ba8585610a2b565b90610a8c565b6003546040516323b872dd60e01b81529192506001600160a01b0316906323b872dd906102f590339030908690600401611ef7565b602060405180830381600087803b15801561030f57600080fd5b505af1158015610323573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103479190611bf7565b6103635760405162461bcd60e51b81526004016101c5906120f6565b60008481526001602052604090205461037c9082610a2b565b600085815260016020526040908190208290555185917fb39477ecc06c5293391f8b73168b655d9c1310af93dbbf043187d79f881bbb8f916103bf91859161242b565b60405180910390a250505050565b6101ce8383838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b61044d8686868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610b3592505050565b610455611ab6565b61046185870187611e08565b90506104a7816000015185858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b6104ea878286868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250610b98915050565b50505050505050565b6105338484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b6105758484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611006915050565b50505050565b600080546001600160a01b031633146105a65760405162461bcd60e51b81526004016101c590612260565b6105b08383611401565b50600192915050565b6000546001600160a01b031681565b60016020526000908152604090205481565b6003546001600160a01b031681565b6106298585858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610b3592505050565b610631611ab6565b61063d84860186611e08565b9050610683816000015184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b6106c4868285858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061143f92505050565b505050505050565b60026020526000908152604090205481565b6060818060200190518101906106f49190611b2b565b60008481526001602052604081205482519293509181808080805b885181101561078c57876107225761078c565b88818151811061072e57fe5b6020026020010151602001519450848810156107645760019687019693508792506107598584610a8c565b915060009750610784565b600196870196610775908790610a8c565b95506107818886610a8c565b97505b60010161070f565b5060008a815260016020526040902087905584156108ef576060856001600160401b03811180156107bc57600080fd5b506040519080825280602002602001820160405280156107f657816020015b6107e3611ace565b8152602001906001900390816107db5790505b50905060005b8681101561088257896108238261081d8a8e51610a8c90919063ffffffff16565b90610a2b565b8151811061082d57fe5b602002602001015182828151811061084157fe5b6020026020010181905250848015610857575080155b1561087a578282828151811061086957fe5b602002602001015160200181815250505b6001016107fc565b506040805180820182526000815290516020808301916108a491859101611f34565b60408051601f198184030181529181529152516108c491906020016123c3565b60408051601f19818403018152918152815160209283012060008e81526002909352912055506108ff565b60008a8152600260205260408120555b6000805b87811015610a1657848015610921575061091e886001610a8c565b81145b1561092e57839150610949565b89818151811061093a57fe5b60200260200101516020015191505b6109698a828151811061095857fe5b602002602001015160000151610a24565b1561099c576109976109918b838151811061098057fe5b60200260200101516000015161197c565b8361197f565b6109d0565b81600160008c84815181106109ad57fe5b602090810291909101810151518252810191909152604001600020805490910190555b8981815181106109dc57fe5b6020026020010151600001518c60008051602061247a83398151915284604051610a069190611f8e565b60405180910390a3600101610903565b505050505050505050505050565b60a01c1590565b600082820183811015610a85576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b9392505050565b6000610a8583836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250611a1f565b6040805180820182526000815260208082018490529151610aef92016123c3565b60408051601f1981840301815291815281516020928301206000858152600290935291205414610b315760405162461bcd60e51b81526004016101c5906122fa565b5050565b6040805180820182526001815260208082018490529151610b5692016123c3565b60408051601f1981840301815291815281516020928301206000858152600290935291205414610b315760405162461bcd60e51b81526004016101c590612038565b606082806020019051810190610bae9190611b2b565b6000868152600160205260408120549192508080805b886020015151811015610cbf5784610bee5760405162461bcd60e51b81526004016101c5906122a7565b600089602001518281518110610c0057fe5b60200260200101519050600092505b8651831015610caa5780878481518110610c2557fe5b6020026020010151600001511415610c9f576000878481518110610c4557fe5b602002602001015160200151905080871015610c795788821415610c70578695508590039350610caa565b60009650610c99565b88821415610c8c57945060009350610caa565b610c968782610a8c565b96505b50610caa565b600190920191610c0f565b8415610cb65750610cbf565b50600101610bc4565b5060008311610ce05760405162461bcd60e51b81526004016101c590611f97565b6000898152600160205260409020805484900390558115610e2557606085516001600160401b0381118015610d1457600080fd5b50604051908082528060200260200182016040528015610d4e57816020015b610d3b611ace565b815260200190600190039081610d335790505b50905060005b8651811015610dba57868181518110610d6957fe5b6020026020010151828281518110610d7d57fe5b602002602001018190525082811415610db25783828281518110610d9d57fe5b60200260200101516020018181525050610dba565b600101610d54565b50604080518082018252600081529051602080830191610ddc91859101611f34565b60408051601f19818403018152918152915251610dfc91906020016123c3565b60408051601f1981840301815291815281516020928301208b5160009081526002909352912055505b81610f9a57845160011415610e535787516000908152600260205260408082208290558a8252812055610f9a565b606060018651036001600160401b0381118015610e6f57600080fd5b50604051908082528060200260200182016040528015610ea957816020015b610e96611ace565b815260200190600190039081610e8e5790505b50905060005b82811015610eea57868181518110610ec357fe5b6020026020010151828281518110610ed757fe5b6020908102919091010152600101610eaf565b50600182015b8651811015610f2f57868181518110610f0557fe5b6020026020010151826001830381518110610f1c57fe5b6020908102919091010152600101610ef0565b50604080518082018252600081529051602080830191610f5191859101611f34565b60408051601f19818403018152918152915251610f7191906020016123c3565b60408051601f1981840301815291815281516020928301208b5160009081526002909352912055505b610fa386610a24565b15610fbf57610fba610fb48761197c565b8461197f565b610fd4565b60008681526001602052604090208054840190555b858960008051602061247a83398151915285604051610ff39190611f8e565b60405180910390a3505050505050505050565b60608280602001905181019061101c9190611b2b565b6000858152600160205260408120549192508080805b85518210156110ee57846110585760405162461bcd60e51b81526004016101c59061212d565b600086838151811061106657fe5b60200260200101516020015190508787848151811061108157fe5b60200260200101516000015114156110c457808610156110aa57600095945084810393506110be565b935060009250836110bb8682610a8c565b95505b506110ee565b808610156110d557600095506110e2565b6110df8682610a8c565b95505b50600190910190611032565b6000841161110e5760405162461bcd60e51b81526004016101c590612373565b6000898152600160205260409020805485900390556060831561122257606087516001600160401b038111801561114457600080fd5b5060405190808252806020026020018201604052801561117e57816020015b61116b611ace565b8152602001906001900390816111635790505b50905060005b88518110156111fd5788818151811061119957fe5b60200260200101518282815181106111ad57fe5b6020026020010181905250898982815181106111c557fe5b60200260200101516000015114156111f557858282815181106111e457fe5b602002602001015160200181815250505b600101611184565b508060405160200161120f9190611f34565b6040516020818303038152906040529150505b8361133357606060018851036001600160401b038111801561124357600080fd5b5060405190808252806020026020018201604052801561127d57816020015b61126a611ace565b8152602001906001900390816112625790505b50905060005b848110156112be5788818151811061129757fe5b60200260200101518282815181106112ab57fe5b6020908102919091010152600101611283565b50600184015b8851811015611303578881815181106112d957fe5b60200260200101518260018303815181106112f057fe5b60209081029190910101526001016112c4565b50805161130f57600192505b806040516020016113209190611f34565b6040516020818303038152906040529150505b811561134d5760008a815260026020526040812055611394565b604080518082018252600081526020808201849052915161136e92016123c3565b60408051601f19818403018152918152815160209283012060008d815260029093529120555b61139d88610a24565b156113b9576113b46113ae8961197c565b8661197f565b6113ce565b60008881526001602052604090208054860190555b878a60008051602061247a833981519152876040516113ed9190611f8e565b60405180910390a350505050505050505050565b6000828152600260205260409020541561142d5760405162461bcd60e51b81526004016101c590612229565b60009182526002602052604090912055565b60008381526001602090815260409091205482519091606091611469919085018101908501611b2b565b9050606081516001600160401b038111801561148457600080fd5b506040519080825280602002602001820160405280156114ae578160200160208202803683370190505b50825190915060005b86602001515181101561160857846114ce57611608565b6000876020015182815181106114e057fe5b6020026020010151905060005b85518110156115fe5786611500576115fe565b85818151811061150c57fe5b6020026020010151600001518214156115f657600086828151811061152d57fe5b602002602001015160200151905060008111156115f4578088106115a5576115558882610a8c565b9750600087838151811061156557fe5b602090810291909101810151015261157e856001610a8c565b94508086838151811061158d57fe5b602002602001018181510191508181525050506115fe565b6115af8189610a8c565b8783815181106115bb57fe5b60200260200101516020018181525050878683815181106115d857fe5b60200260200101818151019150818152505060009750506115fe565b505b6001016114ed565b50506001016114b7565b5060005b83518110156116f7578461161f576116f7565b600084828151811061162d57fe5b602002602001015160200151905060008111156116ee578086106116a4576116558682610a8c565b9550600085838151811061166557fe5b602090810291909101810151015261167e836001610a8c565b92508084838151811061168d57fe5b6020026020010181815101915081815250506116ee565b6116ae8187610a8c565b8583815181106116ba57fe5b60200260200101516020018181525050858483815181106116d757fe5b602002602001018181510191508181525050600095505b5060010161160c565b5060008781526001602052604090208490556060811561176557816001600160401b038111801561172757600080fd5b5060405190808252806020026020018201604052801561176157816020015b61174e611ace565b8152602001906001900390816117465790505b5090505b6000805b85518110156117cc57600086828151811061178057fe5b60200260200101516020015111156117c45785818151811061179e57fe5b60200260200101518383815181106117b257fe5b60209081029190910101526001909101905b600101611769565b508281146117d657fe5b8215611849576040805180820182526000815290516020808301916117fd91869101611f34565b60408051601f1981840301815291815291525161181d91906020016123c3565b60408051601f1981840301815291815281516020928301208a5160009081526002909352912055611863565b600089815260026020526040808220829055895182528120555b60005b855181101561197057600085828151811061187d57fe5b602002602001015111156119685761189a86828151811061095857fe5b156118cf576118ca6118b187838151811061098057fe5b8683815181106118bd57fe5b602002602001015161197f565b611916565b8481815181106118db57fe5b6020026020010151600160008884815181106118f357fe5b602090810291909101810151518252810191909152604001600020805490910190555b85818151811061192257fe5b6020026020010151600001518a60008051602061247a83398151915287848151811061194a57fe5b602002602001015160405161195f9190611f8e565b60405180910390a35b600101611866565b50505050505050505050565b90565b60035460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb906119b19085908590600401611f1b565b602060405180830381600087803b1580156119cb57600080fd5b505af11580156119df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a039190611bf7565b610b315760405162461bcd60e51b81526004016101c59061217e565b60008184841115611aae5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611a73578181015183820152602001611a5b565b50505050905090810190601f168015611aa05780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b60408051808201909152600081526060602082015290565b604080518082019091526000808252602082015290565b60008083601f840112611af6578182fd5b5081356001600160401b03811115611b0c578182fd5b602083019150836020828501011115611b2457600080fd5b9250929050565b60006020808385031215611b3d578182fd5b82516001600160401b0380821115611b53578384fd5b818501915085601f830112611b66578384fd5b8151611b79611b748261245c565b612439565b818152848101908486016040808502870188018b1015611b97578889fd5b8896505b84871015611be85780828c031215611bb1578889fd5b80518181018181108882111715611bc457fe5b82528251815288830151898201528452600196909601959287019290810190611b9b565b50909998505050505050505050565b600060208284031215611c08578081fd5b81518015158114610a85578182fd5b600060208284031215611c28578081fd5b5035919050565b60008060408385031215611c41578081fd5b50508035926020909101359150565b600080600060408486031215611c64578081fd5b8335925060208401356001600160401b03811115611c80578182fd5b611c8c86828701611ae5565b9497909650939450505050565b60008060008060608587031215611cae578081fd5b8435935060208501356001600160401b03811115611cca578182fd5b611cd687828801611ae5565b9598909750949560400135949350505050565b600080600080600060608688031215611d00578081fd5b8535945060208601356001600160401b0380821115611d1d578283fd5b611d2989838a01611ae5565b90965094506040880135915080821115611d41578283fd5b50611d4e88828901611ae5565b969995985093965092949392505050565b60008060008060008060808789031215611d77578081fd5b8635955060208701356001600160401b0380821115611d94578283fd5b611da08a838b01611ae5565b90975095506040890135915080821115611db8578283fd5b50611dc589828a01611ae5565b979a9699509497949695606090950135949350505050565b600080600060608486031215611df1578283fd5b505081359360208301359350604090920135919050565b60006020808385031215611e1a578182fd5b82356001600160401b0380821115611e30578384fd5b9084019060408287031215611e43578384fd5b604051604081018181108382111715611e5857fe5b604052823581528383013582811115611e6f578586fd5b80840193505086601f840112611e83578485fd5b82359150611e93611b748361245c565b82815284810190848601868502860187018a1015611eaf578788fd5b8795505b84861015611ed1578035835260019590950194918601918601611eb3565b50948201949094529695505050505050565b6001600160a01b0391909116815260200190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b03929092168252602082015260400190565b602080825282518282018190526000919060409081850190868401855b82811015611f7657815180518552860151868501529284019290850190600101611f51565b5091979650505050505050565b901515815260200190565b90815260200190565b6020808252602c908201527f5f636c61696d207c2067756172616e746f72206166666f726473203020666f7260408201526b103232b9ba34b730ba34b7b760a11b606082015260800190565b60208082526035908201527f4465706f736974207c20686f6c64696e67735b64657374696e6174696f6e5d206040820152741a5cc81b195cdcc81d1a185b88195e1c1958dd1959605a1b606082015260800190565b60208082526052908201527f4173736574486f6c646572207c207375626d69747465642067756172616e746560408201527f654279746573206461746120646f6573206e6f74206d617463682073746f72656060820152710c840c2e6e6cae89eeae8c6dedaca90c2e6d60731b608082015260a00190565b60208082526026908201527f43616e6e6f74206465706f73697420746f2065787465726e616c2064657374696040820152653730ba34b7b760d11b606082015260800190565b60208082526018908201527f436f756c64206e6f74206465706f736974204552433230730000000000000000604082015260600190565b60208082526031908201527f5f7472616e73666572207c2066726f6d4368616e6e656c206166666f7264732060408201527018103337b9103232b9ba34b730ba34b7b760791b606082015260800190565b6020808252601f908201527f436f756c64206e6f74207472616e7366657220455243323020746f6b656e7300604082015260600190565b6020808252604e908201527f4465706f736974207c20686f6c64696e67735b64657374696e6174696f6e5d2060408201527f616c7265616479206d65657473206f722065786365656473206578706563746560608201526d1912195b19080ac8185b5bdd5b9d60921b608082015260a00190565b6020808252601b908201527f4f7574636f6d65206861736820616c7265616479206578697374730000000000604082015260600190565b60208082526027908201527f4f6e6c7920746865204e6974726f41646a7564696361746f72206973206175746040820152661a1bdc9a5e995960ca1b606082015260800190565b60208082526033908201527f5f636c61696d207c2067756172616e746f724368616e6e656c206166666f7264604082015272399018103337b9103232b9ba34b730ba34b7b760691b606082015260800190565b60208082526053908201527f4173736574486f6c646572207c207375626d697474656420616c6c6f6361746960408201527f6f6e4279746573206461746120646f6573206e6f74206d617463682073746f726060820152720cac840c2e6e6cae89eeae8c6dedaca90c2e6d606b1b608082015260a00190565b60208082526030908201527f5f7472616e736665722066726f6d4368616e6e656c20616c6c6f63617465732060408201526f18103a37903232b9ba34b730ba34b7b760811b606082015260800190565b6000602080835260ff84511681840152808401516040808501528051806060860152835b81811015612403578281018401518682016080015283016123e7565b818111156124145784608083880101525b50601f01601f191693909301608001949350505050565b918252602082015260400190565b6040518181016001600160401b038111828210171561245457fe5b604052919050565b60006001600160401b0382111561246f57fe5b506020908102019056fe1f6b1af341c61650d8ef5dd2094a77e44ce0568e1acb98baa6007033de9009b7a264697066735822122043c835f1d73e18b5df08314a8dcc7f2eca0ae609fbc2e1820dfb0988c280081364736f6c63430007040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c8063a3c863a311610071578063a3c863a31461010f578063aa5f665514610138578063ae9ee18c1461014d578063c24126761461016d578063f1c9caf214610175578063ff86097614610188576100a9565b8063022cbbe8146100ae578063278f2ab8146100c35780632e36b7f8146100d657806394ddd766146100e9578063a3c041a1146100fc575b600080fd5b6100c16100bc366004611c50565b61019b565b005b6100c16100d1366004611ddd565b610213565b6100c16100e4366004611c50565b6103cd565b6100c16100f7366004611d5f565b61040d565b6100c161010a366004611c99565b6104f3565b61012261011d366004611c2f565b61057b565b60405161012f9190611f83565b60405180910390f35b6101406105b9565b60405161012f9190611ee3565b61016061015b366004611c17565b6105c8565b60405161012f9190611f8e565b6101406105da565b6100c1610183366004611ce9565b6105e9565b610160610196366004611c17565b6106cc565b6000546001600160a01b031633146101ce5760405162461bcd60e51b81526004016101c590612260565b60405180910390fd5b61020e8383838080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506106de92505050565b505050565b61021c83610a24565b156102395760405162461bcd60e51b81526004016101c5906120b0565b6000838152600160205260408120548311156102675760405162461bcd60e51b81526004016101c590611fe3565b6102718383610a2b565b6000858152600160205260409020541061029d5760405162461bcd60e51b81526004016101c5906121b5565b6000848152600160205260409020546102c0906102ba8585610a2b565b90610a8c565b6003546040516323b872dd60e01b81529192506001600160a01b0316906323b872dd906102f590339030908690600401611ef7565b602060405180830381600087803b15801561030f57600080fd5b505af1158015610323573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103479190611bf7565b6103635760405162461bcd60e51b81526004016101c5906120f6565b60008481526001602052604090205461037c9082610a2b565b600085815260016020526040908190208290555185917fb39477ecc06c5293391f8b73168b655d9c1310af93dbbf043187d79f881bbb8f916103bf91859161242b565b60405180910390a250505050565b6101ce8383838080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b61044d8686868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610b3592505050565b610455611ab6565b61046185870187611e08565b90506104a7816000015185858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b6104ea878286868080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250889250610b98915050565b50505050505050565b6105338484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b6105758484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250869250611006915050565b50505050565b600080546001600160a01b031633146105a65760405162461bcd60e51b81526004016101c590612260565b6105b08383611401565b50600192915050565b6000546001600160a01b031681565b60016020526000908152604090205481565b6003546001600160a01b031681565b6106298585858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610b3592505050565b610631611ab6565b61063d84860186611e08565b9050610683816000015184848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610ace92505050565b6106c4868285858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061143f92505050565b505050505050565b60026020526000908152604090205481565b6060818060200190518101906106f49190611b2b565b60008481526001602052604081205482519293509181808080805b885181101561078c57876107225761078c565b88818151811061072e57fe5b6020026020010151602001519450848810156107645760019687019693508792506107598584610a8c565b915060009750610784565b600196870196610775908790610a8c565b95506107818886610a8c565b97505b60010161070f565b5060008a815260016020526040902087905584156108ef576060856001600160401b03811180156107bc57600080fd5b506040519080825280602002602001820160405280156107f657816020015b6107e3611ace565b8152602001906001900390816107db5790505b50905060005b8681101561088257896108238261081d8a8e51610a8c90919063ffffffff16565b90610a2b565b8151811061082d57fe5b602002602001015182828151811061084157fe5b6020026020010181905250848015610857575080155b1561087a578282828151811061086957fe5b602002602001015160200181815250505b6001016107fc565b506040805180820182526000815290516020808301916108a491859101611f34565b60408051601f198184030181529181529152516108c491906020016123c3565b60408051601f19818403018152918152815160209283012060008e81526002909352912055506108ff565b60008a8152600260205260408120555b6000805b87811015610a1657848015610921575061091e886001610a8c565b81145b1561092e57839150610949565b89818151811061093a57fe5b60200260200101516020015191505b6109698a828151811061095857fe5b602002602001015160000151610a24565b1561099c576109976109918b838151811061098057fe5b60200260200101516000015161197c565b8361197f565b6109d0565b81600160008c84815181106109ad57fe5b602090810291909101810151518252810191909152604001600020805490910190555b8981815181106109dc57fe5b6020026020010151600001518c60008051602061247a83398151915284604051610a069190611f8e565b60405180910390a3600101610903565b505050505050505050505050565b60a01c1590565b600082820183811015610a85576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b9392505050565b6000610a8583836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250611a1f565b6040805180820182526000815260208082018490529151610aef92016123c3565b60408051601f1981840301815291815281516020928301206000858152600290935291205414610b315760405162461bcd60e51b81526004016101c5906122fa565b5050565b6040805180820182526001815260208082018490529151610b5692016123c3565b60408051601f1981840301815291815281516020928301206000858152600290935291205414610b315760405162461bcd60e51b81526004016101c590612038565b606082806020019051810190610bae9190611b2b565b6000868152600160205260408120549192508080805b886020015151811015610cbf5784610bee5760405162461bcd60e51b81526004016101c5906122a7565b600089602001518281518110610c0057fe5b60200260200101519050600092505b8651831015610caa5780878481518110610c2557fe5b6020026020010151600001511415610c9f576000878481518110610c4557fe5b602002602001015160200151905080871015610c795788821415610c70578695508590039350610caa565b60009650610c99565b88821415610c8c57945060009350610caa565b610c968782610a8c565b96505b50610caa565b600190920191610c0f565b8415610cb65750610cbf565b50600101610bc4565b5060008311610ce05760405162461bcd60e51b81526004016101c590611f97565b6000898152600160205260409020805484900390558115610e2557606085516001600160401b0381118015610d1457600080fd5b50604051908082528060200260200182016040528015610d4e57816020015b610d3b611ace565b815260200190600190039081610d335790505b50905060005b8651811015610dba57868181518110610d6957fe5b6020026020010151828281518110610d7d57fe5b602002602001018190525082811415610db25783828281518110610d9d57fe5b60200260200101516020018181525050610dba565b600101610d54565b50604080518082018252600081529051602080830191610ddc91859101611f34565b60408051601f19818403018152918152915251610dfc91906020016123c3565b60408051601f1981840301815291815281516020928301208b5160009081526002909352912055505b81610f9a57845160011415610e535787516000908152600260205260408082208290558a8252812055610f9a565b606060018651036001600160401b0381118015610e6f57600080fd5b50604051908082528060200260200182016040528015610ea957816020015b610e96611ace565b815260200190600190039081610e8e5790505b50905060005b82811015610eea57868181518110610ec357fe5b6020026020010151828281518110610ed757fe5b6020908102919091010152600101610eaf565b50600182015b8651811015610f2f57868181518110610f0557fe5b6020026020010151826001830381518110610f1c57fe5b6020908102919091010152600101610ef0565b50604080518082018252600081529051602080830191610f5191859101611f34565b60408051601f19818403018152918152915251610f7191906020016123c3565b60408051601f1981840301815291815281516020928301208b5160009081526002909352912055505b610fa386610a24565b15610fbf57610fba610fb48761197c565b8461197f565b610fd4565b60008681526001602052604090208054840190555b858960008051602061247a83398151915285604051610ff39190611f8e565b60405180910390a3505050505050505050565b60608280602001905181019061101c9190611b2b565b6000858152600160205260408120549192508080805b85518210156110ee57846110585760405162461bcd60e51b81526004016101c59061212d565b600086838151811061106657fe5b60200260200101516020015190508787848151811061108157fe5b60200260200101516000015114156110c457808610156110aa57600095945084810393506110be565b935060009250836110bb8682610a8c565b95505b506110ee565b808610156110d557600095506110e2565b6110df8682610a8c565b95505b50600190910190611032565b6000841161110e5760405162461bcd60e51b81526004016101c590612373565b6000898152600160205260409020805485900390556060831561122257606087516001600160401b038111801561114457600080fd5b5060405190808252806020026020018201604052801561117e57816020015b61116b611ace565b8152602001906001900390816111635790505b50905060005b88518110156111fd5788818151811061119957fe5b60200260200101518282815181106111ad57fe5b6020026020010181905250898982815181106111c557fe5b60200260200101516000015114156111f557858282815181106111e457fe5b602002602001015160200181815250505b600101611184565b508060405160200161120f9190611f34565b6040516020818303038152906040529150505b8361133357606060018851036001600160401b038111801561124357600080fd5b5060405190808252806020026020018201604052801561127d57816020015b61126a611ace565b8152602001906001900390816112625790505b50905060005b848110156112be5788818151811061129757fe5b60200260200101518282815181106112ab57fe5b6020908102919091010152600101611283565b50600184015b8851811015611303578881815181106112d957fe5b60200260200101518260018303815181106112f057fe5b60209081029190910101526001016112c4565b50805161130f57600192505b806040516020016113209190611f34565b6040516020818303038152906040529150505b811561134d5760008a815260026020526040812055611394565b604080518082018252600081526020808201849052915161136e92016123c3565b60408051601f19818403018152918152815160209283012060008d815260029093529120555b61139d88610a24565b156113b9576113b46113ae8961197c565b8661197f565b6113ce565b60008881526001602052604090208054860190555b878a60008051602061247a833981519152876040516113ed9190611f8e565b60405180910390a350505050505050505050565b6000828152600260205260409020541561142d5760405162461bcd60e51b81526004016101c590612229565b60009182526002602052604090912055565b60008381526001602090815260409091205482519091606091611469919085018101908501611b2b565b9050606081516001600160401b038111801561148457600080fd5b506040519080825280602002602001820160405280156114ae578160200160208202803683370190505b50825190915060005b86602001515181101561160857846114ce57611608565b6000876020015182815181106114e057fe5b6020026020010151905060005b85518110156115fe5786611500576115fe565b85818151811061150c57fe5b6020026020010151600001518214156115f657600086828151811061152d57fe5b602002602001015160200151905060008111156115f4578088106115a5576115558882610a8c565b9750600087838151811061156557fe5b602090810291909101810151015261157e856001610a8c565b94508086838151811061158d57fe5b602002602001018181510191508181525050506115fe565b6115af8189610a8c565b8783815181106115bb57fe5b60200260200101516020018181525050878683815181106115d857fe5b60200260200101818151019150818152505060009750506115fe565b505b6001016114ed565b50506001016114b7565b5060005b83518110156116f7578461161f576116f7565b600084828151811061162d57fe5b602002602001015160200151905060008111156116ee578086106116a4576116558682610a8c565b9550600085838151811061166557fe5b602090810291909101810151015261167e836001610a8c565b92508084838151811061168d57fe5b6020026020010181815101915081815250506116ee565b6116ae8187610a8c565b8583815181106116ba57fe5b60200260200101516020018181525050858483815181106116d757fe5b602002602001018181510191508181525050600095505b5060010161160c565b5060008781526001602052604090208490556060811561176557816001600160401b038111801561172757600080fd5b5060405190808252806020026020018201604052801561176157816020015b61174e611ace565b8152602001906001900390816117465790505b5090505b6000805b85518110156117cc57600086828151811061178057fe5b60200260200101516020015111156117c45785818151811061179e57fe5b60200260200101518383815181106117b257fe5b60209081029190910101526001909101905b600101611769565b508281146117d657fe5b8215611849576040805180820182526000815290516020808301916117fd91869101611f34565b60408051601f1981840301815291815291525161181d91906020016123c3565b60408051601f1981840301815291815281516020928301208a5160009081526002909352912055611863565b600089815260026020526040808220829055895182528120555b60005b855181101561197057600085828151811061187d57fe5b602002602001015111156119685761189a86828151811061095857fe5b156118cf576118ca6118b187838151811061098057fe5b8683815181106118bd57fe5b602002602001015161197f565b611916565b8481815181106118db57fe5b6020026020010151600160008884815181106118f357fe5b602090810291909101810151518252810191909152604001600020805490910190555b85818151811061192257fe5b6020026020010151600001518a60008051602061247a83398151915287848151811061194a57fe5b602002602001015160405161195f9190611f8e565b60405180910390a35b600101611866565b50505050505050505050565b90565b60035460405163a9059cbb60e01b81526001600160a01b039091169063a9059cbb906119b19085908590600401611f1b565b602060405180830381600087803b1580156119cb57600080fd5b505af11580156119df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a039190611bf7565b610b315760405162461bcd60e51b81526004016101c59061217e565b60008184841115611aae5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015611a73578181015183820152602001611a5b565b50505050905090810190601f168015611aa05780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b60408051808201909152600081526060602082015290565b604080518082019091526000808252602082015290565b60008083601f840112611af6578182fd5b5081356001600160401b03811115611b0c578182fd5b602083019150836020828501011115611b2457600080fd5b9250929050565b60006020808385031215611b3d578182fd5b82516001600160401b0380821115611b53578384fd5b818501915085601f830112611b66578384fd5b8151611b79611b748261245c565b612439565b818152848101908486016040808502870188018b1015611b97578889fd5b8896505b84871015611be85780828c031215611bb1578889fd5b80518181018181108882111715611bc457fe5b82528251815288830151898201528452600196909601959287019290810190611b9b565b50909998505050505050505050565b600060208284031215611c08578081fd5b81518015158114610a85578182fd5b600060208284031215611c28578081fd5b5035919050565b60008060408385031215611c41578081fd5b50508035926020909101359150565b600080600060408486031215611c64578081fd5b8335925060208401356001600160401b03811115611c80578182fd5b611c8c86828701611ae5565b9497909650939450505050565b60008060008060608587031215611cae578081fd5b8435935060208501356001600160401b03811115611cca578182fd5b611cd687828801611ae5565b9598909750949560400135949350505050565b600080600080600060608688031215611d00578081fd5b8535945060208601356001600160401b0380821115611d1d578283fd5b611d2989838a01611ae5565b90965094506040880135915080821115611d41578283fd5b50611d4e88828901611ae5565b969995985093965092949392505050565b60008060008060008060808789031215611d77578081fd5b8635955060208701356001600160401b0380821115611d94578283fd5b611da08a838b01611ae5565b90975095506040890135915080821115611db8578283fd5b50611dc589828a01611ae5565b979a9699509497949695606090950135949350505050565b600080600060608486031215611df1578283fd5b505081359360208301359350604090920135919050565b60006020808385031215611e1a578182fd5b82356001600160401b0380821115611e30578384fd5b9084019060408287031215611e43578384fd5b604051604081018181108382111715611e5857fe5b604052823581528383013582811115611e6f578586fd5b80840193505086601f840112611e83578485fd5b82359150611e93611b748361245c565b82815284810190848601868502860187018a1015611eaf578788fd5b8795505b84861015611ed1578035835260019590950194918601918601611eb3565b50948201949094529695505050505050565b6001600160a01b0391909116815260200190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b03929092168252602082015260400190565b602080825282518282018190526000919060409081850190868401855b82811015611f7657815180518552860151868501529284019290850190600101611f51565b5091979650505050505050565b901515815260200190565b90815260200190565b6020808252602c908201527f5f636c61696d207c2067756172616e746f72206166666f726473203020666f7260408201526b103232b9ba34b730ba34b7b760a11b606082015260800190565b60208082526035908201527f4465706f736974207c20686f6c64696e67735b64657374696e6174696f6e5d206040820152741a5cc81b195cdcc81d1a185b88195e1c1958dd1959605a1b606082015260800190565b60208082526052908201527f4173736574486f6c646572207c207375626d69747465642067756172616e746560408201527f654279746573206461746120646f6573206e6f74206d617463682073746f72656060820152710c840c2e6e6cae89eeae8c6dedaca90c2e6d60731b608082015260a00190565b60208082526026908201527f43616e6e6f74206465706f73697420746f2065787465726e616c2064657374696040820152653730ba34b7b760d11b606082015260800190565b60208082526018908201527f436f756c64206e6f74206465706f736974204552433230730000000000000000604082015260600190565b60208082526031908201527f5f7472616e73666572207c2066726f6d4368616e6e656c206166666f7264732060408201527018103337b9103232b9ba34b730ba34b7b760791b606082015260800190565b6020808252601f908201527f436f756c64206e6f74207472616e7366657220455243323020746f6b656e7300604082015260600190565b6020808252604e908201527f4465706f736974207c20686f6c64696e67735b64657374696e6174696f6e5d2060408201527f616c7265616479206d65657473206f722065786365656473206578706563746560608201526d1912195b19080ac8185b5bdd5b9d60921b608082015260a00190565b6020808252601b908201527f4f7574636f6d65206861736820616c7265616479206578697374730000000000604082015260600190565b60208082526027908201527f4f6e6c7920746865204e6974726f41646a7564696361746f72206973206175746040820152661a1bdc9a5e995960ca1b606082015260800190565b60208082526033908201527f5f636c61696d207c2067756172616e746f724368616e6e656c206166666f7264604082015272399018103337b9103232b9ba34b730ba34b7b760691b606082015260800190565b60208082526053908201527f4173736574486f6c646572207c207375626d697474656420616c6c6f6361746960408201527f6f6e4279746573206461746120646f6573206e6f74206d617463682073746f726060820152720cac840c2e6e6cae89eeae8c6dedaca90c2e6d606b1b608082015260a00190565b60208082526030908201527f5f7472616e736665722066726f6d4368616e6e656c20616c6c6f63617465732060408201526f18103a37903232b9ba34b730ba34b7b760811b606082015260800190565b6000602080835260ff84511681840152808401516040808501528051806060860152835b81811015612403578281018401518682016080015283016123e7565b818111156124145784608083880101525b50601f01601f191693909301608001949350505050565b918252602082015260400190565b6040518181016001600160401b038111828210171561245457fe5b604052919050565b60006001600160401b0382111561246f57fe5b506020908102019056fe1f6b1af341c61650d8ef5dd2094a77e44ce0568e1acb98baa6007033de9009b7a264697066735822122043c835f1d73e18b5df08314a8dcc7f2eca0ae609fbc2e1820dfb0988c280081364736f6c63430007040033",
  "devdoc": {
    "details": "Ther ERC20AssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ERC20 tokens to be escrowed against a state channelId and to be transferred to external destinations.",
    "kind": "dev",
    "methods": {
      "claim(bytes32,bytes,bytes,bytes32)": {
        "details": "Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.",
        "params": {
          "allocationBytes": "The abi.encode of AssetOutcome.Allocation for the __target__",
          "destination": "External destination or channel to transfer funds *to*.",
          "guaranteeBytes": "The abi.encode of Outcome.Guarantee",
          "guarantorChannelId": "Unique identifier for a guarantor state channel."
        }
      },
      "claimAll(bytes32,bytes,bytes)": {
        "details": "Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.",
        "params": {
          "allocationBytes": "The abi.encode of AssetOutcome.Allocation for the __target__",
          "guaranteeBytes": "The abi.encode of Outcome.Guarantee",
          "guarantorChannelId": "Unique identifier for a guarantor state channel."
        }
      },
      "constructor": {
        "details": "Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.",
        "params": {
          "_AdjudicatorAddress": "Address of an Adjudicator  contract, supplied at deploy-time.",
          "_Token": "An ERC20 Token  contract, supplied at deploy-time."
        }
      },
      "deposit(bytes32,uint256,uint256)": {
        "details": "Deposit ERC20 tokens against a given destination.",
        "params": {
          "amount": "The intended number of tokens to be deposited.",
          "destination": "ChannelId to be credited.",
          "expectedHeld": "The amount of tokens that the depositor believes are _already_ escrowed against the channelId."
        }
      },
      "setAssetOutcomeHash(bytes32,bytes32)": {
        "details": "Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.",
        "params": {
          "assetOutcomeHash": "The keccak256 of the abi.encode of the Outcome.",
          "channelId": "Unique identifier for a state channel."
        }
      },
      "transfer(bytes32,bytes,bytes32)": {
        "details": "Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.",
        "params": {
          "allocationBytes": "The abi.encode of AssetOutcome.Allocation",
          "destination": "External destination or channel to transfer funds *to*.",
          "fromChannelId": "Unique identifier for state channel to transfer funds *from*."
        }
      },
      "transferAll(bytes32,bytes)": {
        "details": "Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.",
        "params": {
          "allocationBytes": "The abi.encode of AssetOutcome.Allocation",
          "channelId": "Unique identifier for a state channel."
        }
      },
      "transferAllAdjudicatorOnly(bytes32,bytes)": {
        "details": "Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.",
        "params": {
          "allocationBytes": "The abi.encode of AssetOutcome.Allocation",
          "channelId": "Unique identifier for a state channel."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "claim(bytes32,bytes,bytes,bytes32)": {
        "notice": "Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract."
      },
      "claimAll(bytes32,bytes,bytes)": {
        "notice": "Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract."
      },
      "constructor": {
        "notice": "Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract."
      },
      "deposit(bytes32,uint256,uint256)": {
        "notice": "Deposit ERC20 tokens against a given destination."
      },
      "setAssetOutcomeHash(bytes32,bytes32)": {
        "notice": "Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping."
      },
      "transfer(bytes32,bytes,bytes32)": {
        "notice": "Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries."
      },
      "transferAll(bytes32,bytes)": {
        "notice": "Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract."
      },
      "transferAllAdjudicatorOnly(bytes32,bytes)": {
        "notice": "Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1021,
        "contract": "contracts/ERC20AssetHolder.sol:ERC20AssetHolder",
        "label": "AdjudicatorAddress",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 1025,
        "contract": "contracts/ERC20AssetHolder.sol:ERC20AssetHolder",
        "label": "holdings",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 1029,
        "contract": "contracts/ERC20AssetHolder.sol:ERC20AssetHolder",
        "label": "assetOutcomeHashes",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_bytes32)"
      },
      {
        "astId": 2876,
        "contract": "contracts/ERC20AssetHolder.sol:ERC20AssetHolder",
        "label": "Token",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(IERC20)803"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20)803": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}